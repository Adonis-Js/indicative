import { ParsedRule } from 'indicative-parser';
export declare const rules: {
    above([minValue]: [number]): ParsedRule;
    accepted(): ParsedRule;
    alpha(): ParsedRule;
    alphaNumeric(): ParsedRule;
    array(): ParsedRule;
    boolean(): ParsedRule;
    confirmed(): ParsedRule;
    different([targetField]: [string]): ParsedRule;
    email(): ParsedRule;
    endsWith([substring]: [string]): ParsedRule;
    equals([comparisonValue]: [any]): ParsedRule;
    in(args: any[]): ParsedRule;
    includes([substring]: [string]): ParsedRule;
    integer(): ParsedRule;
    ip(): ParsedRule;
    ipv4(): ParsedRule;
    ipv6(): ParsedRule;
    json(): ParsedRule;
    max([maxLength]: [number]): ParsedRule;
    min([minLength]: [number]): ParsedRule;
    notEquals([comparisonValue]: [any]): ParsedRule;
    notIn(args: any[]): ParsedRule;
    number(): ParsedRule;
    object(): ParsedRule;
    range([min, max]: [number, number]): ParsedRule;
    regex(): ParsedRule;
    required(): ParsedRule;
    requiredIf([targetField]: [string]): ParsedRule;
    requiredWhen([targetField, expectedValue]: [string, any]): ParsedRule;
    requiredWithAll(args: string[]): ParsedRule;
    requiredWithAny(args: string[]): ParsedRule;
    requiredWithoutAll(args: string[]): ParsedRule;
    requiredWithoutAny(args: string[]): ParsedRule;
    same([targetField]: [string]): ParsedRule;
    startsWith([substring]: [string]): ParsedRule;
    string(): ParsedRule;
    subset(args: any[]): ParsedRule;
    under([maxValue]: [number]): ParsedRule;
    url(): ParsedRule;
    after([comparisonDate]: [string | number | Date]): ParsedRule;
    before([comparisonDate]: [string | number | Date]): ParsedRule;
    date(): ParsedRule;
    dateFormat(args: string[]): ParsedRule;
    beforeOffsetOf([diffUnit, key]: [number, import("./Contracts").CalcKeys]): ParsedRule;
    afterOffsetOf([diffUnit, key]: [number, import("./Contracts").CalcKeys]): ParsedRule;
};
